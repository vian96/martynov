Смысл ветвления
Предположим, вы работаете над какой-то статьей. Закончив с ней, вы отправляете черновой вариант на проверку. Затем вы получаете какой-то новый материал, и дополняете его тем, что у вас уже написано. Неожиданно, на полпути вам звонят из комитета по проверке и сообщают, что некоторые заголовки разделов нужно изменить, чтобы они соответствовали спецификациям формата. Что вы будете делать?

Очевидно, вы не хотите отправлять им вашу полуготовую версию с исправленными заголовками. Что вы хотите сделать - это вернуться обратно к черновому варианту, который вы отправляли, поменять заголовки в этой версии и отправить им копию этой версии, храня ваши недавние наработки в безопасности где-нибудь еще.

Это и есть идея, лежащая в основе ветвлений, и Git позволяет легко решить эту проблему.

Обратите внимание на терминологию: термины "ветка" ("branch") и "head" практически синонимичны в Git. За каждой веткой закреплен один head-указатель, и каждый head-указатель указывает на одну ветку. Иногда "ветка" будет употребляться, чтобы обозначить head-указатель и всю историю коммитов, предшествующих ему, между тем как "head" будет использоваться для указания исключительно одного коммита, самого последнего коммита в ветви.

Создание ветки
Перейдем к созданию ветки. Предположим, ваш репозиторий выглядит примерно так:

branch1-1

где (B) - это версия, которую вы отправили на проверку, а (C) - новая версия статьи.

Чтобы вернуться к коммиту (B) и начать работу оттуда, сперва вам надо понять, как него сослаться. Вы можете, например, использовать git log и получить SHA-1 идентификатор коммита (B), или использоваться HEAD^ (как вы помните из прошлого раздела, HEAD^ означает родителя коммита HEAD).

Теперь, выполним команду git branch:

git branch [название-новой-ветки] [ссылка-на-(B)]

или, для примера:

git branch fix-headers HEAD^

Эта команда создаст новый head-указатель (новую ветку), который будет ссылаться на указанный коммит. Если ссылка на коммит в команде опущена, то он будет ссылаться на HEAD.

Теперь наше дерево коммитов выглядит так:

branch2

Переключение между ветками
Чтобы начать работу над заголовками, надо установить fix-headers в положение "current head" (чтобы этот указатель стал текущим - Прим. переводчика). Это делается с помощью команды git checkout:

git checkout [название-указателя]

Команда делает следующее:

Меняет указатель HEAD на [название-указателя].
Переписывает все файлы в каталоге, чтобы они соответствовали выбранному коммиту, на который указывает HEAD.
Важное замечание: если у вас имеются незакоммиченные изменения во время выполнения git checkout, Git будет вести себя очень странно. Эта странность предсказуема и иногда полезна, но лучше ее избегать. Лучшего все закоммитить все новые изменения перед перемещением к новому head-указателю.

После перемещения к head-указателю fix-headers вы исправляете заголовки, потом вы добавляете эти изменения и коммитите их. В результате репозиторий будет выглядеть так:

branch3

(Теперь видно, почему это называется "ветвлением" - у дерева коммитов появилась новая ветка. Обратите внимание, что угол, под которым линия соединяет (B) и (D) не имеет значения - указатели не хранят информацию, горизонтальный ли он или наклоненный).

Предки master - (C), (B), (A), а предки fix-headers - (D), (B), (A). Вы можете увидеть это с помощью команды git log.

Связанные команды
Другие полезные команды по теме:

git branch без аргументов покажет все существующие head-указатели, а так же текущий ("current head") со звездочкой.
git diff [head1]..[head2] покажет отличия между коммитами, на которые ссылаются head1 и head2.
git diff [head1]...[head2] (три точки) покажет отличия между head2 и общим предком head1 и head2 Например, diff master...fix-headers в нашем примере покажет разницу между коммитами (D) и (B).
git log [head1]..[head2] покажет список изменений между head2 и общим предком head1 и head2. С тремя точками он также покажет разницу между head1 и общим предком. Это не очень полезно. (Но менять местами head1 и head2, с другой стороны, очень даже полезно)
Типичная схема применения веток
Самый распространенный способ использования веток в Git - это вести одну "главную" или "корневую" ветку и создавать новые ветки для добавления новых функций в проект. Чаще всего стандартная Git ветка master используется как главная ветка.

Так, в примере выше, лучше было оставить master на коммите (B), где статья была отправлена на оценку. Далее, можно было создать новую ветку, чтобы хранить изменения касательно новой информации.

В идеале, по такой схеме, всегда оставлять ветку master в готовом к релизу состоянии. В других ветках будут находится незаконченные работы, недоработанные функции и т.д.

Такая схема особенно важна, когда над проектом работает несколько разработчиков. Если все они будут делать коммиты в одну ветку, тогда новые функции придется добавлять одним коммитом, чтобы ветка не пришла в негодность. Но если каждый разработчик создаст себе по ветки для добавления новых функций, то коммиты можно будет делать в любое время, независимо от того, закончены ли эти новые функции или нет.

Вот что пользователи Git имеют в виду, когда говорят, что коммиты дешевые. Если вы работаете в своей собственной ветке, нет причин быть осторожным с тем, что именно вы коммитите. Это ни на что другое не повлияет.

Перейти к следующему разделу "Слияние".
